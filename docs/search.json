[
  {
    "objectID": "warmups/warmup0314.html",
    "href": "warmups/warmup0314.html",
    "title": "1. Generates the data",
    "section": "",
    "text": "1. Generates the data\n\nimport torch\n\ntorch.manual_seed(1234)\n\ndef perceptron_data(n_points = 300, noise = 0.2):\n    \n    y = torch.arange(n_points) &gt;= int(n_points/2)\n    X = y[:, None] + torch.normal(0.0, noise, size = (n_points,2))\n    X = torch.cat((X, torch.ones((X.shape[0], 1))), 1)\n\n    # convert y from {0, 1} to {-1, 1}\n    y = 2*y - 1\n\n    return X, y\n\nX, y = perceptron_data(n_points = 300, noise = 0.2)\n\n\nX\n\n\ny\n\ntensor([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n        -1, -1, -1, -1, -1, -1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n         1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n         1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n         1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n         1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n         1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n         1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n         1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n         1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1])\n\n\n\n\n2. three class definitions\n\nimport torch\n\nclass LinearModel:\n\n    def __init__(self):\n        self.w = None \n\n    def score(self, X):\n        \"\"\"\n        Compute the scores for each data point in the feature matrix X. \n        The formula for the ith entry of s is s[i] = &lt;self.w, x[i]&gt;. \n\n        If self.w currently has value None, then it is necessary to first initialize self.w to a random value. \n\n        ARGUMENTS: \n            X, torch.Tensor: the feature matrix. X.size() == (n, p), \n            where n is the number of data points and p is the \n            number of features. This implementation always assumes \n            that the final column of X is a constant column of 1s. \n\n        RETURNS: \n            s torch.Tensor: vector of scores. s.size() = (n,)\n        \"\"\"\n        if self.w is None: \n            self.w = torch.rand((X.size()[1]))\n        \n        s = torch.matmul(X, self.w)\n        \n        return s\n\n    def predict(self, X):\n        \"\"\"\n        Compute the predictions for each data point in the feature matrix X. The prediction for the ith data point is either 0 or 1. \n\n        ARGUMENTS: \n            X, torch.Tensor: the feature matrix. X.size() == (n, p), \n            where n is the number of data points and p is the \n            number of features. This implementation always assumes \n            that the final column of X is a constant column of 1s. \n\n        RETURNS: \n            y_hat, torch.Tensor: vector predictions in {0.0, 1.0}. y_hat.size() = (n,)\n        \"\"\"\n        s = self.score(X)\n        \n        threshold = 0.5\n        y_hat = torch.where(s &gt;= threshold, torch.tensor(1.0), torch.tensor(0.0))\n        \n        return y_hat\n\nclass Perceptron(LinearModel):\n\n    def loss(self, X, y):\n        \"\"\"\n        Compute the misclassification rate. In the perceptron algorithm, the target vector y is assumed to have labels in {-1, 1}. A point i is classified correctly if its score s_i has the same sign as y_i. \n\n        ARGUMENTS: \n            X, torch.Tensor: the feature matrix. X.size() == (n, p), \n            where n is the number of data points and p is the \n            number of features. This implementation always assumes \n            that the final column of X is a constant column of 1s. \n\n            y, torch.Tensor: the target vector.  y.size() = (n,). In the perceptron algorithm, the possible labels for y are assumed to be {-1, 1}\n        \"\"\"\n\n        y_hat = self.predict(X)\n        \n        misc = torch.where(y_hat*y &gt; 0, False, True)\n        \n        misc_rate = (1.0*misc).mean()\n        \n        print(misc_rate)\n        \n        return misc_rate\n\n    def grad(self, X, y):\n        pass \n\nclass PerceptronOptimizer:\n\n    def __init__(self, model):\n        self.model = model \n    \n    def step(self, X, y):\n        \"\"\"\n        Compute one step of the perceptron update using the feature matrix X \n        and target vector y. \n        \"\"\"\n        pass\n    \n    \np = Perceptron()\ns = p.score(X)\nl = p.loss(X, y)\nprint(l == 0.5)\n\ntensor(True)"
  },
  {
    "objectID": "warmups/warmup0416.html",
    "href": "warmups/warmup0416.html",
    "title": "My Awesome CSCI 0451 Blog",
    "section": "",
    "text": "import torch\nfrom matplotlib import pyplot as plt \nplt.style.use('seaborn-v0_8-whitegrid')\n\ndef regression_data(n = 100, w = torch.Tensor([-0.7, 0.5]), x_max = 1):\n\n    x = torch.rand(n)*x_max\n    y = x*w[1] + w[0] + 0.05*torch.randn(n)\n    return x, y\n\nx, y = regression_data()\n# print(f\"{x=}\")\n# print(f\"{y=}\")\n\nplt.scatter(x, y, facecolors = \"none\", edgecolors = \"steelblue\")\nlabs = plt.gca().set(xlabel = r\"$x$\", ylabel = r\"$y$\")\n\n\n\n\n\n\n\n\n\nimport random\n\ndef SGD(x, y, alpha, epochs):\n\n    w_0 = 0.5\n    w_1 = 0.5\n    risk_vec = []\n\n    for t in range(1, epochs+1):\n        \n        # Permute the data indices in a random order.\n        indices = list(range(len(x)))\n        random.shuffle(indices)\n\n        # Then, for each data index i (in the permuted order), perform the following two updates:\n        for i in range(len(indices)):\n            \n            y_i = y[i]\n            x_i = x[i]\n           \n            # update w_0 and w_1 based on SGD formula\n            error = y_i - w_1 * x_i - w_0\n            w_0 += ((2 * alpha)/ t)* w_0 * error\n            w_1 += ((2 * alpha)/ t)* w_1 * error * x_i\n\n        # Calculate the risk for the current w_0 and w_1\n        little_risk = (y - w_1 * x - w_0)**2\n        risk = torch.mean(little_risk)\n        risk_vec.append(risk.item())\n        \n    return risk_vec\n\n\nplt.figure(figsize=(10, 5))\n\nalpha = 0.2\n\n# Plotting the empirical risk during a single epoch\nrisk_vec = SGD(x, y, alpha, 2) ## so we get risk after one update! (technically update twice)\nprint(f\"{risk_vec=}\")\n\nplt.subplot(1, 2, 1)\nplt.plot(range(1, len(risk_vec) + 1), risk_vec)\nplt.xlabel('Epoch')\nplt.ylabel('Empirical Risk')\nplt.title('Empirical Risk Evolution in a Single Epoch')\n\n# Plotting the empirical risk over 100 epochs\nrisk_vec= SGD(x, y, alpha, 100)\nprint(f\"{risk_vec=}\")\n\nplt.subplot(1, 2, 2)\nplt.plot(range(1, len(risk_vec) + 1), risk_vec)\nplt.xlabel('Epochs')\nplt.ylabel('Empirical Risk')\nplt.title('Empirical Risk Evolution over 100 Epochs')\n\nplt.tight_layout()\nplt.show()\n\nrisk_vec=[0.20837946236133575, 0.20835325121879578]\nrisk_vec=[0.20837946236133575, 0.20835325121879578, 0.2083527147769928, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316, 0.2083526998758316]"
  },
  {
    "objectID": "warmups/warmup0408.html",
    "href": "warmups/warmup0408.html",
    "title": "My Awesome CSCI 0451 Blog",
    "section": "",
    "text": "import urllib.request\nfrom PIL import Image\nfrom matplotlib import pyplot as plt\nimport torch\nimport numpy as np\n\ndef read_image(url):\n    urllib.request.urlretrieve(url, \"maru.png\")\n    img = Image.open(\"maru.png\")\n    return torch.tensor(np.array(img)/255).float()\n\nurl = \"https://github.com/middlebury-csci-0451/CSCI-0451-s24/blob/main/assets/img/figs/maru.png?raw=true\"\n\nimg = read_image(url)\n\ndef to_greyscale(im):\n    v = torch.tensor([0.2989, 0.5870, 0.1140])\n    return 1 - img[:,:,:3]@v\n\nimg = to_greyscale(img)\n\nplt.imshow(img, cmap = \"Greys\")\nno_ax = plt.gca().axis(\"off\")\n\nImplement kernel convolution for extracting features from images. Your implementation should accept a 2d array X (think of X as representing a greyscale image) and a square convolutional kernel K. Your implementation should operate using pure torch. You can use any zero-padding strategy, but you do need to explain what your strategy is when presenting.\n\nimport torch.nn.functional as F\nimport torch\n\ndef convolve2d(img, kernel):\n    \n    # padding is kernel row size//2\n    padding = kernel.shape[0] // 2\n    \n    # Apply zero-padding to the input image so that we can have 3 neighbors of our edge pixels\n    img_padded = torch.nn.functional.pad(img.float(), (padding, padding, padding, padding), mode='constant', value=0)\n    \n    # Initialize an empty tensor to store the convolution result\n    conv_output = torch.zeros_like(img)\n    \n    # loop through the rows and cols of the image\n    for i in range(padding, img_padded.shape[0] - padding):\n        for j in range(padding, img_padded.shape[1] - padding):\n            \n            # Go through and copy the image\n            region = img_padded[i - padding:i + padding + 1, j - padding:j + padding + 1]\n            \n            # multiply the region with the kernel and sum\n            conv_output[i - padding, j - padding] = torch.sum(region * kernel)\n    \n    return conv_output\n\n\n# from scipy.signal import convolve2d\n\nkernel = torch.tensor([[-1, -1, -1], [-1,  8, -1], [-1, -1, -1]])\n\nconvd = convolve2d(img, kernel)\n\nplt.imshow(convd, cmap = \"Greys\", vmin = 0, vmax = 0.1)\nplt.gca().axis(\"off\")"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Me!",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/post4/homework4.html",
    "href": "posts/post4/homework4.html",
    "title": " Implementing the Perceptron Algorithm ",
    "section": "",
    "text": "For this blog post I implemented the perceptron algorithm. I then ran several experiments to visualize the changes to my model each iteration and see the improvement of my loss. I investigated how the perceptron implementation changed when given linearly separable data vs not and 2 dimension vs more dimensional data. I also implemented mini-batch and ran experiments to see how this impacted algorithm outcomes. Through these steps, I learned the perceptron algorithm works and how that functionality can change to accommodate different data. Ultimately, I learned that the perceptron algorithm works well to address many different data forms by continuously updating the model based on misclassified points.\nLink to source code (perceptron.py)\nIn perceptron.py I implemented 5 functions: score, predict, loss, grad, and step. Here I will go through to briefly explain each function.\n\nscore: Calculate the score by taking the cross product of the data input and the weights.\npredict: Calculates y_hat where y_hat is 1 when the score is greater than or equal to 0, and 0 otherwise.\nloss: Finds loss by calculating mean of misclassified data points.\ngrad: Calculates score. If misclassified, returns gradient of cross product of data input and output \\[\\mathbb{1}\\left[s_i y_{i} &lt; 0 \\right] y_{i} \\mathbf{x}_{i}\\] Otherwise, return 0 gradient.\nstep: Calls and returns loss function. Adds gradient from grad function to model.\n\n\n%load_ext autoreload\n%autoreload 2\nfrom perceptron import Perceptron, PerceptronOptimizer\nfrom perceptron_minibatch import Perceptron_mini, PerceptronOptimizer_mini\n\nThe autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n\n\n\n\n\nFirst, I used data from warmup to create a plot of linearly separable data.\n\nimport torch\nfrom matplotlib import pyplot as plt\nplt.style.use('seaborn-v0_8-whitegrid')\n\ntorch.manual_seed(1234)\n\ndef perceptron_data(n_points = 300, noise = 0.2, p_dims = 2):\n    \n    y = torch.arange(n_points) &gt;= int(n_points/2)\n    X = y[:, None] + torch.normal(0.0, noise, size = (n_points,p_dims))\n    X = torch.cat((X, torch.ones((X.shape[0], 1))), 1)\n\n    # convert y from {0, 1} to {-1, 1}\n    y = 2*y - 1\n\n    return X, y\n\ndef plot_perceptron_data(X, y, ax):\n    targets = [-1, 1]\n    markers = [\"o\" , \",\"]\n    for i in range(2):\n        ix = y == targets[i]\n        ax.scatter(X[ix,0], X[ix,1], s = 20,  c = y[ix], facecolors = \"none\", edgecolors = \"darkgrey\", cmap = \"BrBG\", vmin = -2, vmax = 2, alpha = 0.5, marker = markers[i])\n    ax.set(xlabel = r\"$x_1$\", ylabel = r\"$x_2$\")\n\nfig, ax = plt.subplots(1, 1)\nX, y = perceptron_data()\nplot_perceptron_data(X, y, ax)\n\n\n\n\n\n\n\n\nSee if perceptron.py code is functional by run the “minimal training loop” code from this section of the notes and eventually achieve loss = 0 on linearly separable data.\n\n# instantiate a model and an optimizer\np = Perceptron() \nopt = PerceptronOptimizer(p)\n\nloss = 1.0\n\n# for keeping track of loss values\nloss_vec = []\n\nn = X.size()[0]\n\nwhile loss &gt; 0: # only terminates if data is linearly separable\n    \n    # not part of the update: just for tracking our progress    \n    loss = p.loss(X, y) \n    loss_vec.append(loss)\n\n    # pick a random data point\n    i = torch.randint(n, size = (1,))\n    x_i = X[[i],:]\n    y_i = y[i]\n\n    # perform a perceptron update using the random data point\n    opt.step(x_i, y_i)\n\nThen I showed visualizations of the data, the separating line, and the evolution of the loss function during training.\nI copied the graph from notes in class to show the change of the loss in iterations of the perceptron algorithm.\n\ndef plot_loss(loss):\n    plt.style.use('seaborn-v0_8-whitegrid')\n    plt.figure(figsize=(10, 6))\n\n\n    plt.plot(loss, color = \"slategrey\")\n    plt.scatter(torch.arange(len(loss)), loss, color = \"slategrey\", s=5)\n    labs = plt.gca().set(xlabel = \"Perceptron Iteration\", ylabel = \"loss\")\n    \n    plt.title(f\"Final loss: {loss[len(loss)-1]:.3f}\")\n\n\nplot_loss(loss_vec)\n\n\n\n\n\n\n\n\nThis shows that the loss gradually decreases over the iterations and eventually reaches 0 (possible as the data is linearly separable).\nWe can then measure the accuracy of our predictions.\n\ndef find_accuracy(X, y):\n\n    predictions = p.predict(X)\n    \n    # convert predictions from {0, 1} to {-1, 1}\n    predictions = 2*predictions - 1\n    \n    correct_preds = (predictions == y).float()\n    accuracy = torch.mean(correct_preds)\n\n    print(f\"Accuracy: {accuracy.item()}\")\n\nfind_accuracy(X, y)\n\nAccuracy: 1.0\n\n\nOur model has perfect accuracy.\n\n\n\nI changed class notes code to include 50 points that overlap the existing classes. This will mean that the data is not necessarily linearly separable like the data before.\n\nimport torch\nfrom matplotlib import pyplot as plt\n\nplt.style.use('seaborn-v0_8-whitegrid')\ntorch.manual_seed(1234)\n\ndef perceptron_data_overlap(n_points=300, noise=0.2, p_dims=2, overlap_points=50):\n   \n    y = torch.arange(n_points) &gt;= int(n_points / 2)\n    X = y[:, None] + torch.normal(0.0, noise, size=(n_points, p_dims))\n    X = torch.cat((X, torch.ones((X.shape[0], 1))), 1)\n\n    # Add overlapping points within the range of existing points\n    overlap_X = torch.rand(overlap_points, p_dims) * (X.max() - X.min()) + X.min()\n    overlap_X = torch.cat((overlap_X, torch.ones((overlap_X.shape[0], 1))), 1)\n    X = torch.cat((X, overlap_X), dim=0)\n\n    # Convert y from {0, 1} to {-1, 1}\n    y = torch.cat((2 * y - 1, torch.ones(overlap_points, dtype=torch.long)))  # Label the overlapping points as class 1\n\n    return X, y\n\ndef plot_perceptron_data_overlap(X, y, ax):\n    targets = [-1, 1]\n    markers = [\"o\", \",\"]\n    for i in range(2):\n        ix = y == targets[i]\n        ax.scatter(X[ix, 0], X[ix, 1], s=20, c=y[ix], facecolors=\"none\", edgecolors=\"darkgrey\", cmap=\"BrBG\", vmin=-2, vmax=2, alpha=0.5, marker=markers[i])\n    ax.set(xlabel=r\"$x_1$\", ylabel=r\"$x_2$\")\n\nfig, ax = plt.subplots(1, 1)\nX, y = perceptron_data_overlap()\nplot_perceptron_data_overlap(X, y, ax)\nplt.show()\n\n\n\n\n\n\n\n\nNext, I reran the perceptron algorithm. The difference with not linearly separable data is that I cannot run the algorithm until the loss is 0 as it will never be 0 for this data. Instead, I ran the data for 1000 iterations based on Pr.Chodrow’s advice in the blog post description. I also including code to visualize model updates.\n\ntorch.manual_seed(1234567)\n\n# initialize a perceptron \np = Perceptron()\nopt = PerceptronOptimizer(p)\nX, y = perceptron_data_overlap()\n\n# initialize for main loop\nloss_vec = []\n\nfor index in range(0, 1000):\n    \n    # pick a random data point\n    i = torch.randint(n, size = (1,))\n    x_i = X[[i],:]\n    y_i = y[i]\n\n    # make an optimization step -- this is where the update actually happens\n    local_loss = opt.step(x_i, y_i)\n\n    # also add the new loss to loss_vec for plotting below\n    loss = p.loss(X, y).item()\n    loss_vec.append(loss)\n\nI then reran code to show the updates of the loss.\n\nplot_loss(loss_vec)\n\n\n\n\n\n\n\n\nHere we can see that the loss decreases over time but does not reach 0 like in the linearly separable case.\n\nfind_accuracy(X, y)\n\nAccuracy: 0.9628571271896362\n\n\nClose, but not perfect, accuracy.\n\n\n\nThe only difference here is that I created data with more than 5 dimensions.\n\nX, y = perceptron_data_overlap(n_points = 300, noise = 0.2, p_dims = 5)\n\nI ran the perceptron algorithm for 1000 iterations, without knowing if the data is linearly separable.\n\ntorch.manual_seed(1234567)\n\n# initialize a perceptron \np = Perceptron()\nopt = PerceptronOptimizer(p)\n\nloss = 1.0\n\n# for keeping track of loss values\nloss_vec_dimen = []\n\nn = X.size()[0]\n\nfor index in range(0, 1000):\n    \n    i = torch.randint(n, size = (1,))\n    x_i = X[[i],:]\n    y_i = y[i]\n\n    # perform a perceptron update using the random data point\n    local_loss = opt.step(x_i, y_i)\n    \n    if (local_loss &gt; 0):\n\n        loss = p.loss(X, y).item()\n        loss_vec_dimen.append(loss)\n        \n\nI then visualized the loss over time.\n\nplot_loss(loss_vec_dimen)\n\n\n\n\n\n\n\n\nBecause the visualization of the loss vector shows that data never fully reaches a loss of 0 after 1000 iterations, we can conclude that the data is probably not linearly separable.\n\nfind_accuracy(X, y)\n\nAccuracy: 0.9571428298950195\n\n\nClose, but not perfect, accuracy with non-linearly separable data.\n\n\n\nI then modified my perceptron.grad() method so that it accepts a submatrix of the feature matrix X of size k*p. I changed the code from:\ndef grad(self, X, y): # should correctly return the “update” part of the perceptron update\n    s = self.score(X)\n\n   # if misclassified, calculate update\n    if s*y &lt;= 0:            \n        update_val = X*y\n        return update_val[0,:]\n    else:\n        return torch.zeros_like(self.w)\nto\ndef grad(self, X, y): # should correctly return the “update” part of the perceptron update\n    s = self.score(X)\n    \n    # choose random learning rate\n    learning_rate = 0.3\n\n    # if misclassified, calculate update\n    misclass = s*y &lt;= 0\n    update_val_row = X*y[:,None]\n    \n    update_val = update_val_row * misclass[:,None]\n    \n    r = learning_rate * torch.mean(update_val, 0)\n    \n    return r\nThis change allowed the grad function to accept submatrices of the feature matrix X instead of just a single point.\n\n\n\nI then performed experiments and create visualizations to demonstrate the following:\nFor linearly separable data, when k = 1, mini-batch perceptron performs similarly to regular perceptron.\n\nX, y = perceptron_data()\n\n\ntorch.manual_seed(1234567)\n\n# initialize a perceptron \np = Perceptron()\nopt = PerceptronOptimizer(p)\n\nloss = 1.0\n\n# for keeping track of loss values\nloss_vec_mini = []\n\nn = X.size()[0]\n\nwhile loss &gt; 0:\n    \n    # K is 1\n    k = 1\n    \n    # get a random submatrix of the feature matrix X and target vector y to implement minibatch\n    ix = torch.randperm(X.size(0))[:k]\n    x_i = X[ix,:]\n    y_i = y[ix]\n    \n    opt.step(x_i, y_i)\n    \n    loss = p.loss(X, y).item()\n    loss_vec_mini.append(loss)\n\n\nplot_loss(loss_vec_mini)\n\n\n\n\n\n\n\n\nLoss goes to 0 after many iterations. And accuracy is perfect.\n\nfind_accuracy(X, y)\n\nAccuracy: 1.0\n\n\nStill with k=1, the perceptron with mini-batch performs similarly to the normal perceptron with overlapping data.\n\nX, y = perceptron_data_overlap()\n\n\ntorch.manual_seed(1234567)\n\n# initialize a perceptron \np = Perceptron()\nopt = PerceptronOptimizer(p)\n\n# for keeping track of loss values\nloss_vec_mini = []\n\nfor index in range(0, 1500):\n    \n    # K is 1\n    k = 1\n    \n    # get a random submatrix of the feature matrix X and target vector y to implement minibatch\n    ix = torch.randperm(X.size(0))[:k]\n    x_i = X[ix,:]\n    y_i = y[ix]\n    \n    opt.step(x_i, y_i)\n    \n    loss = p.loss(X, y).item()\n    loss_vec_mini.append(loss)\n\n\nplot_loss(loss_vec_mini)\n\n\n\n\n\n\n\n\nWe can see that the perceptron reaches a loss close to, but never equal to, zero. We also have nearly perfect accuracy.\n\nfind_accuracy(X, y)\n\nAccuracy: 0.954285740852356\n\n\nFor linearly separable data when k = 10, mini-batch perceptron can still find a separating line in 2d.\n\nX, y = perceptron_data()\n\n\ntorch.manual_seed(1234567)\n\n# initialize a perceptron \np = Perceptron()\nopt = PerceptronOptimizer(p)\n\nloss = 1.0\n\n# for keeping track of loss values\nloss_vec_mini = []\n\nwhile loss &gt; 0:\n    \n    # K is 10\n    k = 10\n    \n    # get a random submatrix of the feature matrix X and target vector y to implement mini-batch\n    ix = torch.randperm(X.size(0))[:k]\n    x_i = X[ix,:]\n    y_i = y[ix]\n    \n    opt.step(x_i, y_i)\n    \n    loss = p.loss(X, y).item()\n    loss_vec_mini.append(loss)\n\n\nplot_loss(loss_vec_mini)\n\n\n\n\n\n\n\n\nHere the loss reaches zero with linearly separable data. We also have 100% accuracy.\n\nfind_accuracy(X, y)\n\nAccuracy: 1.0\n\n\nWhen k = n (that is, the batch size is the size of the entire data set), mini-batch perceptron can converge even when the data is not linearly separable, provided that the learning rate is small enough.\n\nX, y = perceptron_data_overlap()\n\n\ntorch.manual_seed(1234567)\n\n# initialize a perceptron \np = Perceptron()\nopt = PerceptronOptimizer(p)\n\n# for keeping track of loss values\nloss_vec_mini = []\n\nn = X.size()[0]\n\nfor index in range(0, 1000):\n    \n    # K is n\n    k = n\n    \n    # get a random submatrix of the feature matrix X and target vector y to implement mini-batch\n    ix = torch.randperm(X.size(0))[:k]\n    x_i = X[ix,:]\n    y_i = y[ix]\n    \n    opt.step(x_i, y_i)\n    \n    loss = p.loss(X, y).item()\n    loss_vec_mini.append(loss)\n\n\nplot_loss(loss_vec_mini)\n\n\n\n\n\n\n\n\nEven with overlapping data (not linearly separable) the algorithm converges with k=n at very close to 0 loss. Close to perfect accuracy.\n\nfind_accuracy(X, y)\n\nAccuracy: 0.9485714435577393\n\n\n\n\n\n\n\nFor a single iteration of the perceptron algorithm the dot product is taken between w and one row of the feature matrix X, as each row represents a data point. The size of the row of the feature matrix is p, the number of dimensions of the data. Therefore a single iteration’s runtime is O(p).\n\n\n\nWith the mini-batch algorithm, we take the dot product between each data point in the batch instead of just one for each iteration. Therefore it is O(kp) for each algorithm iteration.\n\n\n\n\nThrough this blog post, I learned many important lessons in Machine Learning and computing in general. Firstly, I was able to implement the perceptron algorithm and understand the steps that go into updating a machine learning model. Through my experiments, I validates that my implementation were correct. I learned how to analyze the updates of perceptron and see how the algorithm functions on different data. I developed my abilities to visualize data and use those visualizations to understand both the input data and the algorithm itself. Ultimately, I was able to successfully implement and use the perceptron algorithm for linearly separable data, non-linearly separable data, and data with more than 2 dimensions. With mini-batch, I was able to demonstrate the algorithm functioned similarly to a single point with k=1, can still find a separating line in linearly separable data with k=10, and when k=n converge even without linearly separable data."
  },
  {
    "objectID": "posts/post4/homework4.html#abstract",
    "href": "posts/post4/homework4.html#abstract",
    "title": " Implementing the Perceptron Algorithm ",
    "section": "",
    "text": "For this blog post I implemented the perceptron algorithm. I then ran several experiments to visualize the changes to my model each iteration and see the improvement of my loss. I investigated how the perceptron implementation changed when given linearly separable data vs not and 2 dimension vs more dimensional data. I also implemented mini-batch and ran experiments to see how this impacted algorithm outcomes. Through these steps, I learned the perceptron algorithm works and how that functionality can change to accommodate different data. Ultimately, I learned that the perceptron algorithm works well to address many different data forms by continuously updating the model based on misclassified points.\nLink to source code (perceptron.py)\nIn perceptron.py I implemented 5 functions: score, predict, loss, grad, and step. Here I will go through to briefly explain each function.\n\nscore: Calculate the score by taking the cross product of the data input and the weights.\npredict: Calculates y_hat where y_hat is 1 when the score is greater than or equal to 0, and 0 otherwise.\nloss: Finds loss by calculating mean of misclassified data points.\ngrad: Calculates score. If misclassified, returns gradient of cross product of data input and output \\[\\mathbb{1}\\left[s_i y_{i} &lt; 0 \\right] y_{i} \\mathbf{x}_{i}\\] Otherwise, return 0 gradient.\nstep: Calls and returns loss function. Adds gradient from grad function to model.\n\n\n%load_ext autoreload\n%autoreload 2\nfrom perceptron import Perceptron, PerceptronOptimizer\nfrom perceptron_minibatch import Perceptron_mini, PerceptronOptimizer_mini\n\nThe autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload"
  },
  {
    "objectID": "posts/post4/homework4.html#implement-perceptron-on-linearly-separable-data",
    "href": "posts/post4/homework4.html#implement-perceptron-on-linearly-separable-data",
    "title": " Implementing the Perceptron Algorithm ",
    "section": "",
    "text": "First, I used data from warmup to create a plot of linearly separable data.\n\nimport torch\nfrom matplotlib import pyplot as plt\nplt.style.use('seaborn-v0_8-whitegrid')\n\ntorch.manual_seed(1234)\n\ndef perceptron_data(n_points = 300, noise = 0.2, p_dims = 2):\n    \n    y = torch.arange(n_points) &gt;= int(n_points/2)\n    X = y[:, None] + torch.normal(0.0, noise, size = (n_points,p_dims))\n    X = torch.cat((X, torch.ones((X.shape[0], 1))), 1)\n\n    # convert y from {0, 1} to {-1, 1}\n    y = 2*y - 1\n\n    return X, y\n\ndef plot_perceptron_data(X, y, ax):\n    targets = [-1, 1]\n    markers = [\"o\" , \",\"]\n    for i in range(2):\n        ix = y == targets[i]\n        ax.scatter(X[ix,0], X[ix,1], s = 20,  c = y[ix], facecolors = \"none\", edgecolors = \"darkgrey\", cmap = \"BrBG\", vmin = -2, vmax = 2, alpha = 0.5, marker = markers[i])\n    ax.set(xlabel = r\"$x_1$\", ylabel = r\"$x_2$\")\n\nfig, ax = plt.subplots(1, 1)\nX, y = perceptron_data()\nplot_perceptron_data(X, y, ax)\n\n\n\n\n\n\n\n\nSee if perceptron.py code is functional by run the “minimal training loop” code from this section of the notes and eventually achieve loss = 0 on linearly separable data.\n\n# instantiate a model and an optimizer\np = Perceptron() \nopt = PerceptronOptimizer(p)\n\nloss = 1.0\n\n# for keeping track of loss values\nloss_vec = []\n\nn = X.size()[0]\n\nwhile loss &gt; 0: # only terminates if data is linearly separable\n    \n    # not part of the update: just for tracking our progress    \n    loss = p.loss(X, y) \n    loss_vec.append(loss)\n\n    # pick a random data point\n    i = torch.randint(n, size = (1,))\n    x_i = X[[i],:]\n    y_i = y[i]\n\n    # perform a perceptron update using the random data point\n    opt.step(x_i, y_i)\n\nThen I showed visualizations of the data, the separating line, and the evolution of the loss function during training.\nI copied the graph from notes in class to show the change of the loss in iterations of the perceptron algorithm.\n\ndef plot_loss(loss):\n    plt.style.use('seaborn-v0_8-whitegrid')\n    plt.figure(figsize=(10, 6))\n\n\n    plt.plot(loss, color = \"slategrey\")\n    plt.scatter(torch.arange(len(loss)), loss, color = \"slategrey\", s=5)\n    labs = plt.gca().set(xlabel = \"Perceptron Iteration\", ylabel = \"loss\")\n    \n    plt.title(f\"Final loss: {loss[len(loss)-1]:.3f}\")\n\n\nplot_loss(loss_vec)\n\n\n\n\n\n\n\n\nThis shows that the loss gradually decreases over the iterations and eventually reaches 0 (possible as the data is linearly separable).\nWe can then measure the accuracy of our predictions.\n\ndef find_accuracy(X, y):\n\n    predictions = p.predict(X)\n    \n    # convert predictions from {0, 1} to {-1, 1}\n    predictions = 2*predictions - 1\n    \n    correct_preds = (predictions == y).float()\n    accuracy = torch.mean(correct_preds)\n\n    print(f\"Accuracy: {accuracy.item()}\")\n\nfind_accuracy(X, y)\n\nAccuracy: 1.0\n\n\nOur model has perfect accuracy."
  },
  {
    "objectID": "posts/post4/homework4.html#implement-perceptron-on-data-that-is-not-linearly-separable",
    "href": "posts/post4/homework4.html#implement-perceptron-on-data-that-is-not-linearly-separable",
    "title": " Implementing the Perceptron Algorithm ",
    "section": "",
    "text": "I changed class notes code to include 50 points that overlap the existing classes. This will mean that the data is not necessarily linearly separable like the data before.\n\nimport torch\nfrom matplotlib import pyplot as plt\n\nplt.style.use('seaborn-v0_8-whitegrid')\ntorch.manual_seed(1234)\n\ndef perceptron_data_overlap(n_points=300, noise=0.2, p_dims=2, overlap_points=50):\n   \n    y = torch.arange(n_points) &gt;= int(n_points / 2)\n    X = y[:, None] + torch.normal(0.0, noise, size=(n_points, p_dims))\n    X = torch.cat((X, torch.ones((X.shape[0], 1))), 1)\n\n    # Add overlapping points within the range of existing points\n    overlap_X = torch.rand(overlap_points, p_dims) * (X.max() - X.min()) + X.min()\n    overlap_X = torch.cat((overlap_X, torch.ones((overlap_X.shape[0], 1))), 1)\n    X = torch.cat((X, overlap_X), dim=0)\n\n    # Convert y from {0, 1} to {-1, 1}\n    y = torch.cat((2 * y - 1, torch.ones(overlap_points, dtype=torch.long)))  # Label the overlapping points as class 1\n\n    return X, y\n\ndef plot_perceptron_data_overlap(X, y, ax):\n    targets = [-1, 1]\n    markers = [\"o\", \",\"]\n    for i in range(2):\n        ix = y == targets[i]\n        ax.scatter(X[ix, 0], X[ix, 1], s=20, c=y[ix], facecolors=\"none\", edgecolors=\"darkgrey\", cmap=\"BrBG\", vmin=-2, vmax=2, alpha=0.5, marker=markers[i])\n    ax.set(xlabel=r\"$x_1$\", ylabel=r\"$x_2$\")\n\nfig, ax = plt.subplots(1, 1)\nX, y = perceptron_data_overlap()\nplot_perceptron_data_overlap(X, y, ax)\nplt.show()\n\n\n\n\n\n\n\n\nNext, I reran the perceptron algorithm. The difference with not linearly separable data is that I cannot run the algorithm until the loss is 0 as it will never be 0 for this data. Instead, I ran the data for 1000 iterations based on Pr.Chodrow’s advice in the blog post description. I also including code to visualize model updates.\n\ntorch.manual_seed(1234567)\n\n# initialize a perceptron \np = Perceptron()\nopt = PerceptronOptimizer(p)\nX, y = perceptron_data_overlap()\n\n# initialize for main loop\nloss_vec = []\n\nfor index in range(0, 1000):\n    \n    # pick a random data point\n    i = torch.randint(n, size = (1,))\n    x_i = X[[i],:]\n    y_i = y[i]\n\n    # make an optimization step -- this is where the update actually happens\n    local_loss = opt.step(x_i, y_i)\n\n    # also add the new loss to loss_vec for plotting below\n    loss = p.loss(X, y).item()\n    loss_vec.append(loss)\n\nI then reran code to show the updates of the loss.\n\nplot_loss(loss_vec)\n\n\n\n\n\n\n\n\nHere we can see that the loss decreases over time but does not reach 0 like in the linearly separable case.\n\nfind_accuracy(X, y)\n\nAccuracy: 0.9628571271896362\n\n\nClose, but not perfect, accuracy."
  },
  {
    "objectID": "posts/post4/homework4.html#implement-perceptron-on-data-with-more-than-2-dimensions",
    "href": "posts/post4/homework4.html#implement-perceptron-on-data-with-more-than-2-dimensions",
    "title": " Implementing the Perceptron Algorithm ",
    "section": "",
    "text": "The only difference here is that I created data with more than 5 dimensions.\n\nX, y = perceptron_data_overlap(n_points = 300, noise = 0.2, p_dims = 5)\n\nI ran the perceptron algorithm for 1000 iterations, without knowing if the data is linearly separable.\n\ntorch.manual_seed(1234567)\n\n# initialize a perceptron \np = Perceptron()\nopt = PerceptronOptimizer(p)\n\nloss = 1.0\n\n# for keeping track of loss values\nloss_vec_dimen = []\n\nn = X.size()[0]\n\nfor index in range(0, 1000):\n    \n    i = torch.randint(n, size = (1,))\n    x_i = X[[i],:]\n    y_i = y[i]\n\n    # perform a perceptron update using the random data point\n    local_loss = opt.step(x_i, y_i)\n    \n    if (local_loss &gt; 0):\n\n        loss = p.loss(X, y).item()\n        loss_vec_dimen.append(loss)\n        \n\nI then visualized the loss over time.\n\nplot_loss(loss_vec_dimen)\n\n\n\n\n\n\n\n\nBecause the visualization of the loss vector shows that data never fully reaches a loss of 0 after 1000 iterations, we can conclude that the data is probably not linearly separable.\n\nfind_accuracy(X, y)\n\nAccuracy: 0.9571428298950195\n\n\nClose, but not perfect, accuracy with non-linearly separable data."
  },
  {
    "objectID": "posts/post4/homework4.html#implement-minibatch",
    "href": "posts/post4/homework4.html#implement-minibatch",
    "title": " Implementing the Perceptron Algorithm ",
    "section": "",
    "text": "I then modified my perceptron.grad() method so that it accepts a submatrix of the feature matrix X of size k*p. I changed the code from:\ndef grad(self, X, y): # should correctly return the “update” part of the perceptron update\n    s = self.score(X)\n\n   # if misclassified, calculate update\n    if s*y &lt;= 0:            \n        update_val = X*y\n        return update_val[0,:]\n    else:\n        return torch.zeros_like(self.w)\nto\ndef grad(self, X, y): # should correctly return the “update” part of the perceptron update\n    s = self.score(X)\n    \n    # choose random learning rate\n    learning_rate = 0.3\n\n    # if misclassified, calculate update\n    misclass = s*y &lt;= 0\n    update_val_row = X*y[:,None]\n    \n    update_val = update_val_row * misclass[:,None]\n    \n    r = learning_rate * torch.mean(update_val, 0)\n    \n    return r\nThis change allowed the grad function to accept submatrices of the feature matrix X instead of just a single point."
  },
  {
    "objectID": "posts/post4/homework4.html#minibatch-perceptron-experiments",
    "href": "posts/post4/homework4.html#minibatch-perceptron-experiments",
    "title": " Implementing the Perceptron Algorithm ",
    "section": "",
    "text": "I then performed experiments and create visualizations to demonstrate the following:\nFor linearly separable data, when k = 1, mini-batch perceptron performs similarly to regular perceptron.\n\nX, y = perceptron_data()\n\n\ntorch.manual_seed(1234567)\n\n# initialize a perceptron \np = Perceptron()\nopt = PerceptronOptimizer(p)\n\nloss = 1.0\n\n# for keeping track of loss values\nloss_vec_mini = []\n\nn = X.size()[0]\n\nwhile loss &gt; 0:\n    \n    # K is 1\n    k = 1\n    \n    # get a random submatrix of the feature matrix X and target vector y to implement minibatch\n    ix = torch.randperm(X.size(0))[:k]\n    x_i = X[ix,:]\n    y_i = y[ix]\n    \n    opt.step(x_i, y_i)\n    \n    loss = p.loss(X, y).item()\n    loss_vec_mini.append(loss)\n\n\nplot_loss(loss_vec_mini)\n\n\n\n\n\n\n\n\nLoss goes to 0 after many iterations. And accuracy is perfect.\n\nfind_accuracy(X, y)\n\nAccuracy: 1.0\n\n\nStill with k=1, the perceptron with mini-batch performs similarly to the normal perceptron with overlapping data.\n\nX, y = perceptron_data_overlap()\n\n\ntorch.manual_seed(1234567)\n\n# initialize a perceptron \np = Perceptron()\nopt = PerceptronOptimizer(p)\n\n# for keeping track of loss values\nloss_vec_mini = []\n\nfor index in range(0, 1500):\n    \n    # K is 1\n    k = 1\n    \n    # get a random submatrix of the feature matrix X and target vector y to implement minibatch\n    ix = torch.randperm(X.size(0))[:k]\n    x_i = X[ix,:]\n    y_i = y[ix]\n    \n    opt.step(x_i, y_i)\n    \n    loss = p.loss(X, y).item()\n    loss_vec_mini.append(loss)\n\n\nplot_loss(loss_vec_mini)\n\n\n\n\n\n\n\n\nWe can see that the perceptron reaches a loss close to, but never equal to, zero. We also have nearly perfect accuracy.\n\nfind_accuracy(X, y)\n\nAccuracy: 0.954285740852356\n\n\nFor linearly separable data when k = 10, mini-batch perceptron can still find a separating line in 2d.\n\nX, y = perceptron_data()\n\n\ntorch.manual_seed(1234567)\n\n# initialize a perceptron \np = Perceptron()\nopt = PerceptronOptimizer(p)\n\nloss = 1.0\n\n# for keeping track of loss values\nloss_vec_mini = []\n\nwhile loss &gt; 0:\n    \n    # K is 10\n    k = 10\n    \n    # get a random submatrix of the feature matrix X and target vector y to implement mini-batch\n    ix = torch.randperm(X.size(0))[:k]\n    x_i = X[ix,:]\n    y_i = y[ix]\n    \n    opt.step(x_i, y_i)\n    \n    loss = p.loss(X, y).item()\n    loss_vec_mini.append(loss)\n\n\nplot_loss(loss_vec_mini)\n\n\n\n\n\n\n\n\nHere the loss reaches zero with linearly separable data. We also have 100% accuracy.\n\nfind_accuracy(X, y)\n\nAccuracy: 1.0\n\n\nWhen k = n (that is, the batch size is the size of the entire data set), mini-batch perceptron can converge even when the data is not linearly separable, provided that the learning rate is small enough.\n\nX, y = perceptron_data_overlap()\n\n\ntorch.manual_seed(1234567)\n\n# initialize a perceptron \np = Perceptron()\nopt = PerceptronOptimizer(p)\n\n# for keeping track of loss values\nloss_vec_mini = []\n\nn = X.size()[0]\n\nfor index in range(0, 1000):\n    \n    # K is n\n    k = n\n    \n    # get a random submatrix of the feature matrix X and target vector y to implement mini-batch\n    ix = torch.randperm(X.size(0))[:k]\n    x_i = X[ix,:]\n    y_i = y[ix]\n    \n    opt.step(x_i, y_i)\n    \n    loss = p.loss(X, y).item()\n    loss_vec_mini.append(loss)\n\n\nplot_loss(loss_vec_mini)\n\n\n\n\n\n\n\n\nEven with overlapping data (not linearly separable) the algorithm converges with k=n at very close to 0 loss. Close to perfect accuracy.\n\nfind_accuracy(X, y)\n\nAccuracy: 0.9485714435577393"
  },
  {
    "objectID": "posts/post4/homework4.html#discussion-question",
    "href": "posts/post4/homework4.html#discussion-question",
    "title": " Implementing the Perceptron Algorithm ",
    "section": "",
    "text": "For a single iteration of the perceptron algorithm the dot product is taken between w and one row of the feature matrix X, as each row represents a data point. The size of the row of the feature matrix is p, the number of dimensions of the data. Therefore a single iteration’s runtime is O(p).\n\n\n\nWith the mini-batch algorithm, we take the dot product between each data point in the batch instead of just one for each iteration. Therefore it is O(kp) for each algorithm iteration."
  },
  {
    "objectID": "posts/post4/homework4.html#conclusion",
    "href": "posts/post4/homework4.html#conclusion",
    "title": " Implementing the Perceptron Algorithm ",
    "section": "",
    "text": "Through this blog post, I learned many important lessons in Machine Learning and computing in general. Firstly, I was able to implement the perceptron algorithm and understand the steps that go into updating a machine learning model. Through my experiments, I validates that my implementation were correct. I learned how to analyze the updates of perceptron and see how the algorithm functions on different data. I developed my abilities to visualize data and use those visualizations to understand both the input data and the algorithm itself. Ultimately, I was able to successfully implement and use the perceptron algorithm for linearly separable data, non-linearly separable data, and data with more than 2 dimensions. With mini-batch, I was able to demonstrate the algorithm functioned similarly to a single point with k=1, can still find a separating line in linearly separable data with k=10, and when k=n converge even without linearly separable data."
  },
  {
    "objectID": "posts/post6/homework6.html",
    "href": "posts/post6/homework6.html",
    "title": " Newton’s Method for Logistic Regression ",
    "section": "",
    "text": "%load_ext autoreload\n%autoreload 2\nfrom NewtonOptimizer import NewtonOptimizer\nimport sys\nsys.path.append('/Users/lindseyschweitzer/Documents/GitHub/lfschweitzer.github.io/')\n\nfrom posts.post5.logistic import LogisticRegression, GradientDescentOptimizer\n\nThe autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n\n\n\n\nBlog post includes implementing Newton’s Method for Logistic Regression and performing 3 experiments.\nThese three experiments include: 1. When alpha is chosen appropriately, Newton’s method converges to the correct choice of w. 2. Under at least some circumstances, Newton’s method can converge much faster than standard gradient descent, in the sense of decreasing the empirical risk. 3. If alpha is too large, Newton’s method fails to converge.\n\n\nBefore doing any experiments, I had to generate data for a classification problem.\n\nimport torch\n\ndef classification_data(n_points = 300, noise = 0.2, p_dims = 2):\n    \n    y = torch.arange(n_points) &gt;= int(n_points/2)\n    y = 1.0*y\n    X = y[:, None] + torch.normal(0.0, noise, size = (n_points,p_dims))\n    X = torch.cat((X, torch.ones((X.shape[0], 1))), 1)\n    \n    return X, y\n\nPlot the data\n\nfrom matplotlib import pyplot as plt\nplt.style.use('seaborn-v0_8-whitegrid')\n\ndef plot_classification_data(X, y, ax):\n    targets = [0, 1]\n    markers = [\"o\" , \",\"]\n    for i in range(2):\n        ix = y == targets[i]\n        ax.scatter(X[ix,0], X[ix,1], s = 20,  c = y[ix], facecolors = \"none\", edgecolors = \"darkgrey\", cmap = \"BrBG\", vmin = -2, vmax = 2, alpha = 0.5, marker = markers[i])\n    ax.set(xlabel = r\"$x_1$\", ylabel = r\"$x_2$\")\n    \n    \nfig, ax = plt.subplots(1, 1)\n\n# p_dims is 2\nX, y = classification_data(noise = 0.2)\nplot_classification_data(X, y, ax)\n\n\n\n\n\n\n\n\nCode to graph a straight line\n\ndef draw_line(w, x_min, x_max, ax, **kwargs):\n    w_ = w.flatten()\n    x = torch.linspace(x_min, x_max, 101)\n    y = -(w_[0]*x + w_[2])/w_[1]\n    l = ax.plot(x, y, **kwargs)\n\n\n\n\n\n# initialize a Logistic Regression \nLR = LogisticRegression() \nopt = NewtonOptimizer(LR)\n\n# initialize for main loop\nloss_vec_van = []\n\nfor index in range(5000):\n    \n    opt.step(X, y, alpha = 0.3)\n    \n    loss = LR.loss(X, y).item()\n    loss_vec_van.append(loss)\n\n\ndef find_accuracy(X, y):\n\n    predictions = LR.predict(X)\n    correct_preds = (predictions == y).float()\n    accuracy = torch.mean(correct_preds)\n\n    print(f\"Accuracy: {accuracy.item()}\")\n\nfind_accuracy(X, y)\n\nAccuracy: 1.0\n\n\nPlot the loss over time over the 2000 iterations.\n\nimport numpy as np\n\ndef plot_loss(loss, label= \"\"):\n    plt.style.use('seaborn-v0_8-whitegrid')\n    plt.figure(figsize=(10, 6))\n\n    \n    plt.plot(loss, color = \"blue\", label=label)\n    plt.scatter(torch.arange(len(loss)), loss, color = \"slategrey\", s=5)\n    plt.gca().set(xlabel = \"Perceptron Iteration (Updates Only)\", ylabel = \"loss\")\n    \n    plt.title(f\"Final loss: {loss[len(loss)-1]:.3f}\")\n\nplot_loss(loss_vec_van)\n\n\n\n\n\n\n\n\n\n\n\nFirst lets do standard gradient descent so we can compare it to Newton’s method later.\n\nX, y = classification_data(noise = 3)\n\nLR_Stand = LogisticRegression() \nopt = GradientDescentOptimizer(LR_Stand)\n\n# initialize for main loop\nloss_vec_stand = []\n\nfor index in range(5000):\n    \n    # for vanilla gradient descent, alpha must be sufficiently small and beta must be 0\n    opt.step(X, y, alpha = 0.2, beta = 0)\n    loss = LR_Stand.loss(X, y).item()\n    loss_vec_stand.append(loss)\n\n\nfind_accuracy(X, y)\n\nAccuracy: 0.5733333230018616\n\n\nNow, lets show do Newton’s method to compare the decrease in empirical risk.\n\n# Use the same data as before\n\n# initialize a Logistic Regression and use Newton Optimizer\nLR_Newt = LogisticRegression() \nopt = NewtonOptimizer(LR_Newt)\n\nloss_vec_newt = []\n\nfor index in range(5000):\n    \n    opt.step(X, y, alpha = 0.2)\n    \n    loss = LR_Newt.loss(X, y).item()\n    loss_vec_newt.append(loss)\n\n\nfind_accuracy(X, y)\n\nAccuracy: 0.5899999737739563\n\n\nNow let’s compare the decrease in empirical risk:\n\nplt.plot(loss_vec_stand, label='Standard Gradient Descent')\nplt.plot(loss_vec_newt, color='green', label=\"Newton's Method\")\n\nplt.xlabel(\"Iterations\")\nplt.ylabel(\"Loss\")\nplt.legend()"
  },
  {
    "objectID": "posts/post6/homework6.html#data-generation",
    "href": "posts/post6/homework6.html#data-generation",
    "title": " Newton’s Method for Logistic Regression ",
    "section": "",
    "text": "Before doing any experiments, I had to generate data for a classification problem.\n\nimport torch\n\ndef classification_data(n_points = 300, noise = 0.2, p_dims = 2):\n    \n    y = torch.arange(n_points) &gt;= int(n_points/2)\n    y = 1.0*y\n    X = y[:, None] + torch.normal(0.0, noise, size = (n_points,p_dims))\n    X = torch.cat((X, torch.ones((X.shape[0], 1))), 1)\n    \n    return X, y\n\nPlot the data\n\nfrom matplotlib import pyplot as plt\nplt.style.use('seaborn-v0_8-whitegrid')\n\ndef plot_classification_data(X, y, ax):\n    targets = [0, 1]\n    markers = [\"o\" , \",\"]\n    for i in range(2):\n        ix = y == targets[i]\n        ax.scatter(X[ix,0], X[ix,1], s = 20,  c = y[ix], facecolors = \"none\", edgecolors = \"darkgrey\", cmap = \"BrBG\", vmin = -2, vmax = 2, alpha = 0.5, marker = markers[i])\n    ax.set(xlabel = r\"$x_1$\", ylabel = r\"$x_2$\")\n    \n    \nfig, ax = plt.subplots(1, 1)\n\n# p_dims is 2\nX, y = classification_data(noise = 0.2)\nplot_classification_data(X, y, ax)\n\n\n\n\n\n\n\n\nCode to graph a straight line\n\ndef draw_line(w, x_min, x_max, ax, **kwargs):\n    w_ = w.flatten()\n    x = torch.linspace(x_min, x_max, 101)\n    y = -(w_[0]*x + w_[2])/w_[1]\n    l = ax.plot(x, y, **kwargs)"
  },
  {
    "objectID": "posts/post6/homework6.html#when-alpha-is-chosen-appropriately-newtons-method-converges-to-the-correct-choice-of-w.",
    "href": "posts/post6/homework6.html#when-alpha-is-chosen-appropriately-newtons-method-converges-to-the-correct-choice-of-w.",
    "title": " Newton’s Method for Logistic Regression ",
    "section": "",
    "text": "# initialize a Logistic Regression \nLR = LogisticRegression() \nopt = NewtonOptimizer(LR)\n\n# initialize for main loop\nloss_vec_van = []\n\nfor index in range(5000):\n    \n    opt.step(X, y, alpha = 0.3)\n    \n    loss = LR.loss(X, y).item()\n    loss_vec_van.append(loss)\n\n\ndef find_accuracy(X, y):\n\n    predictions = LR.predict(X)\n    correct_preds = (predictions == y).float()\n    accuracy = torch.mean(correct_preds)\n\n    print(f\"Accuracy: {accuracy.item()}\")\n\nfind_accuracy(X, y)\n\nAccuracy: 1.0\n\n\nPlot the loss over time over the 2000 iterations.\n\nimport numpy as np\n\ndef plot_loss(loss, label= \"\"):\n    plt.style.use('seaborn-v0_8-whitegrid')\n    plt.figure(figsize=(10, 6))\n\n    \n    plt.plot(loss, color = \"blue\", label=label)\n    plt.scatter(torch.arange(len(loss)), loss, color = \"slategrey\", s=5)\n    plt.gca().set(xlabel = \"Perceptron Iteration (Updates Only)\", ylabel = \"loss\")\n    \n    plt.title(f\"Final loss: {loss[len(loss)-1]:.3f}\")\n\nplot_loss(loss_vec_van)"
  },
  {
    "objectID": "posts/post6/homework6.html#under-at-least-some-circumstances-newtons-method-can-converge-much-faster-than-standard-gradient-descent-in-the-sense-of-decreasing-the-empirical-risk.",
    "href": "posts/post6/homework6.html#under-at-least-some-circumstances-newtons-method-can-converge-much-faster-than-standard-gradient-descent-in-the-sense-of-decreasing-the-empirical-risk.",
    "title": " Newton’s Method for Logistic Regression ",
    "section": "",
    "text": "First lets do standard gradient descent so we can compare it to Newton’s method later.\n\nX, y = classification_data(noise = 3)\n\nLR_Stand = LogisticRegression() \nopt = GradientDescentOptimizer(LR_Stand)\n\n# initialize for main loop\nloss_vec_stand = []\n\nfor index in range(5000):\n    \n    # for vanilla gradient descent, alpha must be sufficiently small and beta must be 0\n    opt.step(X, y, alpha = 0.2, beta = 0)\n    loss = LR_Stand.loss(X, y).item()\n    loss_vec_stand.append(loss)\n\n\nfind_accuracy(X, y)\n\nAccuracy: 0.5733333230018616\n\n\nNow, lets show do Newton’s method to compare the decrease in empirical risk.\n\n# Use the same data as before\n\n# initialize a Logistic Regression and use Newton Optimizer\nLR_Newt = LogisticRegression() \nopt = NewtonOptimizer(LR_Newt)\n\nloss_vec_newt = []\n\nfor index in range(5000):\n    \n    opt.step(X, y, alpha = 0.2)\n    \n    loss = LR_Newt.loss(X, y).item()\n    loss_vec_newt.append(loss)\n\n\nfind_accuracy(X, y)\n\nAccuracy: 0.5899999737739563\n\n\nNow let’s compare the decrease in empirical risk:\n\nplt.plot(loss_vec_stand, label='Standard Gradient Descent')\nplt.plot(loss_vec_newt, color='green', label=\"Newton's Method\")\n\nplt.xlabel(\"Iterations\")\nplt.ylabel(\"Loss\")\nplt.legend()"
  },
  {
    "objectID": "posts/post1/homework1.html",
    "href": "posts/post1/homework1.html",
    "title": " Palmer Penguins ",
    "section": "",
    "text": "The Palmer Penguins data set was collected by Dr. Kristen Gorman and the Palmer Station, Anartica LTER, a member of the Long Term Ecological Research Network. It contains physiological measurements from three species of penguins and is widely used in data analysis. My goal with homework 1 is to identify three characteristics (two quantitative and one qualitative) and a model, which I then train, to identify penguin species with 100% testing accuracy.\n\nimport pandas as pd\n\ntrain_url = \"https://raw.githubusercontent.com/PhilChodrow/ml-notes/main/data/palmer-penguins/train.csv\"\ntrain = pd.read_csv(train_url)\n\n\ntrain.head()\n\n\n\n\n\n\n\n\nstudyName\nSample Number\nSpecies\nRegion\nIsland\nStage\nIndividual ID\nClutch Completion\nDate Egg\nCulmen Length (mm)\nCulmen Depth (mm)\nFlipper Length (mm)\nBody Mass (g)\nSex\nDelta 15 N (o/oo)\nDelta 13 C (o/oo)\nComments\n\n\n\n\n0\nPAL0809\n31\nChinstrap penguin (Pygoscelis antarctica)\nAnvers\nDream\nAdult, 1 Egg Stage\nN63A1\nYes\n11/24/08\n40.9\n16.6\n187.0\n3200.0\nFEMALE\n9.08458\n-24.54903\nNaN\n\n\n1\nPAL0809\n41\nChinstrap penguin (Pygoscelis antarctica)\nAnvers\nDream\nAdult, 1 Egg Stage\nN74A1\nYes\n11/24/08\n49.0\n19.5\n210.0\n3950.0\nMALE\n9.53262\n-24.66867\nNaN\n\n\n2\nPAL0708\n4\nGentoo penguin (Pygoscelis papua)\nAnvers\nBiscoe\nAdult, 1 Egg Stage\nN32A2\nYes\n11/27/07\n50.0\n15.2\n218.0\n5700.0\nMALE\n8.25540\n-25.40075\nNaN\n\n\n3\nPAL0708\n15\nGentoo penguin (Pygoscelis papua)\nAnvers\nBiscoe\nAdult, 1 Egg Stage\nN38A1\nYes\n12/3/07\n45.8\n14.6\n210.0\n4200.0\nFEMALE\n7.79958\n-25.62618\nNaN\n\n\n4\nPAL0809\n34\nChinstrap penguin (Pygoscelis antarctica)\nAnvers\nDream\nAdult, 1 Egg Stage\nN65A2\nYes\n11/24/08\n51.0\n18.8\n203.0\n4100.0\nMALE\n9.23196\n-24.17282\nNaN\n\n\n\n\n\n\n\n\n\n\nTo start my exploration into the penguin data, I first sough to understand the data by plotting it\n\nimport seaborn as sns\n\n# body mass vs specie with colors for gender\n\n# replace the column with the first word in each entry\ntrain[\"Species\"] = train[\"Species\"].str.split().str.get(0)\n\nsns.catplot(data=train, x=\"Species\", y=\"Body Mass (g)\", hue=\"Sex\")\n\n/Users/lindseyschweitzer/anaconda3/envs/ml-0451/lib/python3.9/site-packages/seaborn/_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  with pd.option_context('mode.use_inf_as_na', True):\n/Users/lindseyschweitzer/anaconda3/envs/ml-0451/lib/python3.9/site-packages/seaborn/_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  with pd.option_context('mode.use_inf_as_na', True):\n\n\n\n\n\n\n\n\n\nThis plot shows penguins as points colored by sex, with species as the x-axis and body mass (in grams) on the y-axis. This plot displays that on average, male penguins are larger than female penguins. It also shows a trend of Gentoo species of penguins larger than Chinstrap or Adelie penguins- who are relatively similar in size. This indicates that Body Mass (g) could potentially be a useful indicator in indicating species type. It is also important to note that the separation of gender allows us to make these assertions. Gento male penguins are generally larger than Adelie male penguins and the same follows with female penguins of these same two species. However, Gentoo female penguins are roughly the same size as Adelie male penguins. Therefore gender might be a useful tool in predicting penguin species.\n\nsns.catplot(data=train, kind=\"violin\", x=\"Delta 13 C (o/oo)\", y=\"Island\", hue=\"Species\")\n\n\n\n\n\n\n\n\nThis plot shows the penguins of different species with different colors graphed on Delta 13 C (o/oo) and Island location. Delta 13(o/oo) is an interesting indicator as it is widely used as an indicator of diet especially in reference to vegetation. This therefore shows that there could be a large difference in diet between Chinstrap and the other two species of penguins. Adelie penguins are present in all three islands whereas Gentoo and Chinstrap penguins are isolated to one of the three. Therefore Island could be a helpful indicator of species type, but probably would not be indicative by itself.\n\ntable = train.groupby(['Species', 'Sex']).aggregate({'Culmen Length (mm)' : ['min', 'max','mean']})\nprint(table)\n\n                 Culmen Length (mm)                 \n                                min   max       mean\nSpecies   Sex                                       \nAdelie    FEMALE               34.0  42.2  37.426415\n          MALE                 34.6  46.0  40.404918\nChinstrap FEMALE               40.9  58.0  46.722581\n          MALE                 49.0  55.8  51.334615\nGentoo    .                    44.5  44.5  44.500000\n          FEMALE               40.9  50.5  45.455102\n          MALE                 44.4  55.9  49.006818\n\n\nThis table indicates that on average male penguins have longer Culmen Length than their female counterparts. Male Gentoo penguins have longer Culmens then male Chinstraps who have longer Culmens than male Adelie penguins while the order for female penguins descends for Chinstrap, Gentoo, then Adelie. These distinctions could serve useful in training our model to differentiate species. It also serves to note that the gender distinction matters when comparing species.\n\n\n\nI then attempted to find three features of the data (one qualitative and two quantitative) and train a model on these features that achieves 100% testing accuracy.\nFirst I did data preparation to prepare the quantitative columns of the data\n\nfrom sklearn.preprocessing import LabelEncoder\nle = LabelEncoder()\nle.fit(train[\"Species\"])\n\ndef prepare_data(df):\n  df = df.drop([\"studyName\", \"Sample Number\", \"Individual ID\", \"Date Egg\", \"Comments\", \"Region\"], axis = 1)\n  df = df[df[\"Sex\"] != \".\"]\n  df = df.dropna()\n  y = le.transform(df[\"Species\"])\n  df = df.drop([\"Species\"], axis = 1)\n  df = pd.get_dummies(df)\n  return df, y\n\nX_train, y_train = prepare_data(train)\n\n\nX_train.head()\n\n\n\n\n\n\n\n\nCulmen Length (mm)\nCulmen Depth (mm)\nFlipper Length (mm)\nBody Mass (g)\nDelta 15 N (o/oo)\nDelta 13 C (o/oo)\nIsland_Biscoe\nIsland_Dream\nIsland_Torgersen\nStage_Adult, 1 Egg Stage\nClutch Completion_No\nClutch Completion_Yes\nSex_FEMALE\nSex_MALE\n\n\n\n\n0\n40.9\n16.6\n187.0\n3200.0\n9.08458\n-24.54903\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue\nTrue\nFalse\n\n\n1\n49.0\n19.5\n210.0\n3950.0\n9.53262\n-24.66867\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue\n\n\n2\n50.0\n15.2\n218.0\n5700.0\n8.25540\n-25.40075\nTrue\nFalse\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue\n\n\n3\n45.8\n14.6\n210.0\n4200.0\n7.79958\n-25.62618\nTrue\nFalse\nFalse\nTrue\nFalse\nTrue\nTrue\nFalse\n\n\n4\n51.0\n18.8\n203.0\n4100.0\n9.23196\n-24.17282\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue\n\n\n\n\n\n\n\nI completed an exhaustive iterative search to find the best markers. I used cross validation one each combination of one qualitative and two quantitative column with different models keeping track of the best score for each model. In terms of models I used a Logistic Regression, Decision Tree Classifier, SVC, and Random Forrest Classifier. For the Decision Tree Classifier and the Random Forrest Classifier I used grid search across the amount of parameters to identify the optimal maximum depth. For SVC I used grid search to find the optimal value for gamma across a wide array of numbers. With the best markers of each model, I also saved the columns of the best score.\n\nfrom itertools import combinations\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.model_selection import GridSearchCV, cross_val_score\nfrom sklearn.svm import SVC\nfrom sklearn.ensemble import RandomForestClassifier\nimport numpy as np\n\nall_qual_cols = [\"Clutch Completion\", \"Sex\", \"Island\",'Stage_Adult, 1 Egg Stage']\nall_quant_cols = ['Culmen Length (mm)', 'Culmen Depth (mm)', 'Flipper Length (mm)','Body Mass (g)','Delta 15 N (o/oo)','Delta 13 C (o/oo)',]\n\nbestLRScore = 0.0\nbestLRCols=[]\ncol_combos = []\n\n\nbestDTCScore = 0.0\nbestDTCCols=[]\n\nbestSVMScore = 0.0\nbestSVMCols=[]\n\nbestRFCScore = 0.0\nbestRFCCols=[]\n\nfor qual in all_qual_cols: \n  qual_cols = [col for col in X_train.columns if qual in col ]\n  \n  for pair in combinations(all_quant_cols, 2):\n    cols = qual_cols + list(pair) \n\n    #LogisticRegression\n    LR = LogisticRegression(max_iter=10000000000000000000)\n        \n    LRScore = cross_val_score(LR, X_train[cols], y_train, cv=5).mean()\n    \n    # keep track of best Logistic Regression Score\n    if LRScore &gt;= bestLRScore :\n      bestLRScore = LRScore\n      bestLRCols = cols\n        \n    #DecisionTreeClassifier\n    param_grid = { 'max_depth': [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, None ]}\n    \n    tree = DecisionTreeClassifier()\n    grid_search = GridSearchCV(tree, param_grid, cv=5)\n    grid_search.fit(X_train[cols], y_train)\n    DTCScore  = grid_search.best_score_\n        \n    if(DTCScore &gt; bestDTCScore):\n      bestDTCScore = DTCScore\n      bestDTCCols = cols\n      bestDTCDepth = grid_search.best_params_\n      \n    \n    # Random Forrest Classifier    \n    forrest = RandomForestClassifier(random_state=0)\n    grid_search = GridSearchCV(forrest, param_grid, cv=5)\n    grid_search.fit(X_train[cols], y_train)\n    \n    RFCScore  = grid_search.best_score_\n    \n    # keep track of best RFC Score  \n    if(RFCScore &gt; bestRFCScore):\n      bestRFCScore = RFCScore\n      bestRFCCols = cols\n      bestRFCDepth = grid_search.best_params_\n    \n    #SVC\n    SVM = SVC()\n\n    # use grid search to find best gamma for SVM\n    g = {'gamma': 10.0 ** np.arange(-5, 5) }\n\n    grid_search = GridSearchCV(SVM, g, cv=5)\n    grid_search.fit(X_train[cols], y_train)\n    \n    SVMScore  = grid_search.best_score_   \n    \n    # keep track of best SVM Score\n    if(SVMScore &gt; bestSVMScore):\n      bestSVMScore = SVMScore\n      bestSVMCols = cols\n        \n\n  \nprint(\"best LR\",bestLRCols, \":\", bestLRScore)\nprint(\"best DTC\",bestDTCCols, \":\", bestDTCScore)\nprint(\"best max depth:\", bestDTCDepth)\nprint(\"best RFC\", bestRFCCols, \":\", bestRFCScore)\nprint(\"best max depth:\", bestRFCDepth)\nprint(\"best SVM\", bestSVMCols, \":\", bestSVMScore)\n\nbest LR ['Sex_FEMALE', 'Sex_MALE', 'Culmen Length (mm)', 'Culmen Depth (mm)'] : 0.9883107088989442\nbest DTC ['Sex_FEMALE', 'Sex_MALE', 'Culmen Length (mm)', 'Culmen Depth (mm)'] : 0.9765460030165913\nbest max depth: {'max_depth': 7}\nbest RFC ['Sex_FEMALE', 'Sex_MALE', 'Culmen Length (mm)', 'Flipper Length (mm)'] : 0.9844645550527904\nbest max depth: {'max_depth': 5}\nbest SVM ['Sex_FEMALE', 'Sex_MALE', 'Culmen Length (mm)', 'Culmen Depth (mm)'] : 0.9805429864253394\n\n\nFrom my iterative search through the features and the different models I was able to find that the best score was Logistic Regression with Culmen Length (mm), Culmen Depth (mm), and Sex. This model with these features had a 0.9883107088989442% classification rate. This made sense as I noted in my data exploration that sex was an important distinction to make when comparing different features to classify teh species.\n\n\n\nNext I prepared the test data by shorting my Species column and identifying selected columns of the best fitting models- Culmen Length (mm), Culmen Depth (mm), and Sex for Logistic Regression. On my test data I achieved 100% testing accuracy.\n\ntest_url = \"https://raw.githubusercontent.com/PhilChodrow/ml-notes/main/data/palmer-penguins/test.csv\"\ntest = pd.read_csv(test_url)\n\ntest[\"Species\"] = test[\"Species\"].str.split().str.get(0)\n\nX_test, y_test = prepare_data(test)\n\nselected_cols = ['Culmen Length (mm)', 'Culmen Depth (mm)','Sex_FEMALE', 'Sex_MALE']\n\nX_train_selected = X_train[selected_cols]\nX_test_selected = X_test[selected_cols]\n\nLR = LogisticRegression()\nLR.fit(X_train_selected, y_train)\ntestScore = LR.score(X_test_selected, y_test)\n\nprint(testScore)\n\n1.0\n\n\n/Users/lindseyschweitzer/anaconda3/envs/ml-0451/lib/python3.9/site-packages/sklearn/linear_model/_logistic.py:460: ConvergenceWarning: lbfgs failed to converge (status=1):\nSTOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n\nIncrease the number of iterations (max_iter) or scale the data as shown in:\n    https://scikit-learn.org/stable/modules/preprocessing.html\nPlease also refer to the documentation for alternative solver options:\n    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n  n_iter_i = _check_optimize_result(\n\n\n\n\n\nI visualized how my model worked on the training and test data by plotting the data and displaying the decision regions of my model.\n\nfrom matplotlib import pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Patch\n\ndef plot_regions(model, X, y):\n    \n    x0 = X[X.columns[0]]\n    x1 = X[X.columns[1]]\n    qual_features = X.columns[2:]\n    \n    fig, axarr = plt.subplots(1, len(qual_features), figsize = (7, 3))\n\n    # create a grid\n    grid_x = np.linspace(x0.min(),x0.max(),501)\n    grid_y = np.linspace(x1.min(),x1.max(),501)\n    xx, yy = np.meshgrid(grid_x, grid_y)\n    \n    XX = xx.ravel()\n    YY = yy.ravel()\n\n    for i in range(len(qual_features)):\n      XY = pd.DataFrame({\n        X.columns[0] : XX,\n        X.columns[1] : YY\n      })\n\n      for j in qual_features:\n        XY[j] = 0\n\n      XY[qual_features[i]] = 1\n\n      p = model.predict(XY)\n      p = p.reshape(xx.shape)\n      \n      \n      # use contour plot to visualize the predictions\n      axarr[i].contourf(xx, yy, p, cmap = \"jet\", alpha = 0.2, vmin = 0, vmax = 2)\n      \n      ix = X[qual_features[i]] == 1\n      # plot the data\n      axarr[i].scatter(x0[ix], x1[ix], c = y[ix], cmap = \"jet\", vmin = 0, vmax = 2)\n      \n      axarr[i].set(xlabel = X.columns[0], \n            ylabel  = X.columns[1], \n            title = qual_features[i])\n      \n      patches = []\n      for color, spec in zip([\"red\", \"green\", \"blue\"], [\"Adelie\", \"Chinstrap\", \"Gentoo\"]):\n        patches.append(Patch(color = color, label = spec))\n\n      plt.legend(title = \"Species\", handles = patches, loc = \"best\")\n      \n      plt.tight_layout()\n\nplot_regions(LR, X_train_selected, y_train)\n\n\n\n\n\n\n\n\n\nplot_regions(LR, X_test_selected, y_test)\n\n\n\n\n\n\n\n\n\n\n\nFinally, to visualize the successful identification of my model with my three chosen characteristics I used a confusion matrix on the testing data.\n\nfrom sklearn.metrics import confusion_matrix\n\ny_test_pred = LR.predict(X_test_selected)\nC = confusion_matrix(y_test, y_test_pred)\n\nfor i in range(3):\n    for j in range(3):\n        print(f\"There were {C[i,j]} {le.classes_[i]} penguin(s) who were classified as {le.classes_[j]}.\")\n\nThere were 31 Adelie penguin(s) who were classified as Adelie.\nThere were 0 Adelie penguin(s) who were classified as Chinstrap.\nThere were 0 Adelie penguin(s) who were classified as Gentoo.\nThere were 0 Chinstrap penguin(s) who were classified as Adelie.\nThere were 11 Chinstrap penguin(s) who were classified as Chinstrap.\nThere were 0 Chinstrap penguin(s) who were classified as Gentoo.\nThere were 0 Gentoo penguin(s) who were classified as Adelie.\nThere were 0 Gentoo penguin(s) who were classified as Chinstrap.\nThere were 26 Gentoo penguin(s) who were classified as Gentoo.\n\n\n\nfrom sklearn.metrics import confusion_matrix\n\nconfusion_matrix(y_test, y_test_pred, normalize = \"true\")\n\narray([[1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.]])\n\n\nThis is a perfect confusion matrix as the model has 100% testing accuracy in classifying the penguins. This result is exactly what we want.\n\n\n\nThis blog post taught me many things. Firstly, it allowed me to gain practice exploring and understanding data. I was able to explore the Palmer Penguin data set by creating tables and graphs. Then I was able to use the knowledge gained by the exploration to train my own classifier. I was able to become familiar with various different machine learning models through this assignment: Logistic Regression, Decision Tree Classifier, Random Forest Classifier, and Support Vector Machines. Through this process, I learned about grid search and how to find optimal parameters. I then got practice training a Logistic Regression with Culmen Length (mm), Culmen Depth (mm), and Sex and finally testing it on our test data to get a 100% accuracy rate. Not only did I become more familiar with this particular data set, but I was able to learn skills in how to analyze data and build and test Machine Learning Models."
  },
  {
    "objectID": "posts/post1/homework1.html#introduction",
    "href": "posts/post1/homework1.html#introduction",
    "title": " Palmer Penguins ",
    "section": "",
    "text": "The Palmer Penguins data set was collected by Dr. Kristen Gorman and the Palmer Station, Anartica LTER, a member of the Long Term Ecological Research Network. It contains physiological measurements from three species of penguins and is widely used in data analysis. My goal with homework 1 is to identify three characteristics (two quantitative and one qualitative) and a model, which I then train, to identify penguin species with 100% testing accuracy.\n\nimport pandas as pd\n\ntrain_url = \"https://raw.githubusercontent.com/PhilChodrow/ml-notes/main/data/palmer-penguins/train.csv\"\ntrain = pd.read_csv(train_url)\n\n\ntrain.head()\n\n\n\n\n\n\n\n\nstudyName\nSample Number\nSpecies\nRegion\nIsland\nStage\nIndividual ID\nClutch Completion\nDate Egg\nCulmen Length (mm)\nCulmen Depth (mm)\nFlipper Length (mm)\nBody Mass (g)\nSex\nDelta 15 N (o/oo)\nDelta 13 C (o/oo)\nComments\n\n\n\n\n0\nPAL0809\n31\nChinstrap penguin (Pygoscelis antarctica)\nAnvers\nDream\nAdult, 1 Egg Stage\nN63A1\nYes\n11/24/08\n40.9\n16.6\n187.0\n3200.0\nFEMALE\n9.08458\n-24.54903\nNaN\n\n\n1\nPAL0809\n41\nChinstrap penguin (Pygoscelis antarctica)\nAnvers\nDream\nAdult, 1 Egg Stage\nN74A1\nYes\n11/24/08\n49.0\n19.5\n210.0\n3950.0\nMALE\n9.53262\n-24.66867\nNaN\n\n\n2\nPAL0708\n4\nGentoo penguin (Pygoscelis papua)\nAnvers\nBiscoe\nAdult, 1 Egg Stage\nN32A2\nYes\n11/27/07\n50.0\n15.2\n218.0\n5700.0\nMALE\n8.25540\n-25.40075\nNaN\n\n\n3\nPAL0708\n15\nGentoo penguin (Pygoscelis papua)\nAnvers\nBiscoe\nAdult, 1 Egg Stage\nN38A1\nYes\n12/3/07\n45.8\n14.6\n210.0\n4200.0\nFEMALE\n7.79958\n-25.62618\nNaN\n\n\n4\nPAL0809\n34\nChinstrap penguin (Pygoscelis antarctica)\nAnvers\nDream\nAdult, 1 Egg Stage\nN65A2\nYes\n11/24/08\n51.0\n18.8\n203.0\n4100.0\nMALE\n9.23196\n-24.17282\nNaN"
  },
  {
    "objectID": "posts/post1/homework1.html#explore",
    "href": "posts/post1/homework1.html#explore",
    "title": " Palmer Penguins ",
    "section": "",
    "text": "To start my exploration into the penguin data, I first sough to understand the data by plotting it\n\nimport seaborn as sns\n\n# body mass vs specie with colors for gender\n\n# replace the column with the first word in each entry\ntrain[\"Species\"] = train[\"Species\"].str.split().str.get(0)\n\nsns.catplot(data=train, x=\"Species\", y=\"Body Mass (g)\", hue=\"Sex\")\n\n/Users/lindseyschweitzer/anaconda3/envs/ml-0451/lib/python3.9/site-packages/seaborn/_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  with pd.option_context('mode.use_inf_as_na', True):\n/Users/lindseyschweitzer/anaconda3/envs/ml-0451/lib/python3.9/site-packages/seaborn/_oldcore.py:1119: FutureWarning: use_inf_as_na option is deprecated and will be removed in a future version. Convert inf values to NaN before operating instead.\n  with pd.option_context('mode.use_inf_as_na', True):\n\n\n\n\n\n\n\n\n\nThis plot shows penguins as points colored by sex, with species as the x-axis and body mass (in grams) on the y-axis. This plot displays that on average, male penguins are larger than female penguins. It also shows a trend of Gentoo species of penguins larger than Chinstrap or Adelie penguins- who are relatively similar in size. This indicates that Body Mass (g) could potentially be a useful indicator in indicating species type. It is also important to note that the separation of gender allows us to make these assertions. Gento male penguins are generally larger than Adelie male penguins and the same follows with female penguins of these same two species. However, Gentoo female penguins are roughly the same size as Adelie male penguins. Therefore gender might be a useful tool in predicting penguin species.\n\nsns.catplot(data=train, kind=\"violin\", x=\"Delta 13 C (o/oo)\", y=\"Island\", hue=\"Species\")\n\n\n\n\n\n\n\n\nThis plot shows the penguins of different species with different colors graphed on Delta 13 C (o/oo) and Island location. Delta 13(o/oo) is an interesting indicator as it is widely used as an indicator of diet especially in reference to vegetation. This therefore shows that there could be a large difference in diet between Chinstrap and the other two species of penguins. Adelie penguins are present in all three islands whereas Gentoo and Chinstrap penguins are isolated to one of the three. Therefore Island could be a helpful indicator of species type, but probably would not be indicative by itself.\n\ntable = train.groupby(['Species', 'Sex']).aggregate({'Culmen Length (mm)' : ['min', 'max','mean']})\nprint(table)\n\n                 Culmen Length (mm)                 \n                                min   max       mean\nSpecies   Sex                                       \nAdelie    FEMALE               34.0  42.2  37.426415\n          MALE                 34.6  46.0  40.404918\nChinstrap FEMALE               40.9  58.0  46.722581\n          MALE                 49.0  55.8  51.334615\nGentoo    .                    44.5  44.5  44.500000\n          FEMALE               40.9  50.5  45.455102\n          MALE                 44.4  55.9  49.006818\n\n\nThis table indicates that on average male penguins have longer Culmen Length than their female counterparts. Male Gentoo penguins have longer Culmens then male Chinstraps who have longer Culmens than male Adelie penguins while the order for female penguins descends for Chinstrap, Gentoo, then Adelie. These distinctions could serve useful in training our model to differentiate species. It also serves to note that the gender distinction matters when comparing species."
  },
  {
    "objectID": "posts/post1/homework1.html#model",
    "href": "posts/post1/homework1.html#model",
    "title": " Palmer Penguins ",
    "section": "",
    "text": "I then attempted to find three features of the data (one qualitative and two quantitative) and train a model on these features that achieves 100% testing accuracy.\nFirst I did data preparation to prepare the quantitative columns of the data\n\nfrom sklearn.preprocessing import LabelEncoder\nle = LabelEncoder()\nle.fit(train[\"Species\"])\n\ndef prepare_data(df):\n  df = df.drop([\"studyName\", \"Sample Number\", \"Individual ID\", \"Date Egg\", \"Comments\", \"Region\"], axis = 1)\n  df = df[df[\"Sex\"] != \".\"]\n  df = df.dropna()\n  y = le.transform(df[\"Species\"])\n  df = df.drop([\"Species\"], axis = 1)\n  df = pd.get_dummies(df)\n  return df, y\n\nX_train, y_train = prepare_data(train)\n\n\nX_train.head()\n\n\n\n\n\n\n\n\nCulmen Length (mm)\nCulmen Depth (mm)\nFlipper Length (mm)\nBody Mass (g)\nDelta 15 N (o/oo)\nDelta 13 C (o/oo)\nIsland_Biscoe\nIsland_Dream\nIsland_Torgersen\nStage_Adult, 1 Egg Stage\nClutch Completion_No\nClutch Completion_Yes\nSex_FEMALE\nSex_MALE\n\n\n\n\n0\n40.9\n16.6\n187.0\n3200.0\n9.08458\n-24.54903\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue\nTrue\nFalse\n\n\n1\n49.0\n19.5\n210.0\n3950.0\n9.53262\n-24.66867\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue\n\n\n2\n50.0\n15.2\n218.0\n5700.0\n8.25540\n-25.40075\nTrue\nFalse\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue\n\n\n3\n45.8\n14.6\n210.0\n4200.0\n7.79958\n-25.62618\nTrue\nFalse\nFalse\nTrue\nFalse\nTrue\nTrue\nFalse\n\n\n4\n51.0\n18.8\n203.0\n4100.0\n9.23196\n-24.17282\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue\nFalse\nTrue\n\n\n\n\n\n\n\nI completed an exhaustive iterative search to find the best markers. I used cross validation one each combination of one qualitative and two quantitative column with different models keeping track of the best score for each model. In terms of models I used a Logistic Regression, Decision Tree Classifier, SVC, and Random Forrest Classifier. For the Decision Tree Classifier and the Random Forrest Classifier I used grid search across the amount of parameters to identify the optimal maximum depth. For SVC I used grid search to find the optimal value for gamma across a wide array of numbers. With the best markers of each model, I also saved the columns of the best score.\n\nfrom itertools import combinations\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.model_selection import GridSearchCV, cross_val_score\nfrom sklearn.svm import SVC\nfrom sklearn.ensemble import RandomForestClassifier\nimport numpy as np\n\nall_qual_cols = [\"Clutch Completion\", \"Sex\", \"Island\",'Stage_Adult, 1 Egg Stage']\nall_quant_cols = ['Culmen Length (mm)', 'Culmen Depth (mm)', 'Flipper Length (mm)','Body Mass (g)','Delta 15 N (o/oo)','Delta 13 C (o/oo)',]\n\nbestLRScore = 0.0\nbestLRCols=[]\ncol_combos = []\n\n\nbestDTCScore = 0.0\nbestDTCCols=[]\n\nbestSVMScore = 0.0\nbestSVMCols=[]\n\nbestRFCScore = 0.0\nbestRFCCols=[]\n\nfor qual in all_qual_cols: \n  qual_cols = [col for col in X_train.columns if qual in col ]\n  \n  for pair in combinations(all_quant_cols, 2):\n    cols = qual_cols + list(pair) \n\n    #LogisticRegression\n    LR = LogisticRegression(max_iter=10000000000000000000)\n        \n    LRScore = cross_val_score(LR, X_train[cols], y_train, cv=5).mean()\n    \n    # keep track of best Logistic Regression Score\n    if LRScore &gt;= bestLRScore :\n      bestLRScore = LRScore\n      bestLRCols = cols\n        \n    #DecisionTreeClassifier\n    param_grid = { 'max_depth': [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, None ]}\n    \n    tree = DecisionTreeClassifier()\n    grid_search = GridSearchCV(tree, param_grid, cv=5)\n    grid_search.fit(X_train[cols], y_train)\n    DTCScore  = grid_search.best_score_\n        \n    if(DTCScore &gt; bestDTCScore):\n      bestDTCScore = DTCScore\n      bestDTCCols = cols\n      bestDTCDepth = grid_search.best_params_\n      \n    \n    # Random Forrest Classifier    \n    forrest = RandomForestClassifier(random_state=0)\n    grid_search = GridSearchCV(forrest, param_grid, cv=5)\n    grid_search.fit(X_train[cols], y_train)\n    \n    RFCScore  = grid_search.best_score_\n    \n    # keep track of best RFC Score  \n    if(RFCScore &gt; bestRFCScore):\n      bestRFCScore = RFCScore\n      bestRFCCols = cols\n      bestRFCDepth = grid_search.best_params_\n    \n    #SVC\n    SVM = SVC()\n\n    # use grid search to find best gamma for SVM\n    g = {'gamma': 10.0 ** np.arange(-5, 5) }\n\n    grid_search = GridSearchCV(SVM, g, cv=5)\n    grid_search.fit(X_train[cols], y_train)\n    \n    SVMScore  = grid_search.best_score_   \n    \n    # keep track of best SVM Score\n    if(SVMScore &gt; bestSVMScore):\n      bestSVMScore = SVMScore\n      bestSVMCols = cols\n        \n\n  \nprint(\"best LR\",bestLRCols, \":\", bestLRScore)\nprint(\"best DTC\",bestDTCCols, \":\", bestDTCScore)\nprint(\"best max depth:\", bestDTCDepth)\nprint(\"best RFC\", bestRFCCols, \":\", bestRFCScore)\nprint(\"best max depth:\", bestRFCDepth)\nprint(\"best SVM\", bestSVMCols, \":\", bestSVMScore)\n\nbest LR ['Sex_FEMALE', 'Sex_MALE', 'Culmen Length (mm)', 'Culmen Depth (mm)'] : 0.9883107088989442\nbest DTC ['Sex_FEMALE', 'Sex_MALE', 'Culmen Length (mm)', 'Culmen Depth (mm)'] : 0.9765460030165913\nbest max depth: {'max_depth': 7}\nbest RFC ['Sex_FEMALE', 'Sex_MALE', 'Culmen Length (mm)', 'Flipper Length (mm)'] : 0.9844645550527904\nbest max depth: {'max_depth': 5}\nbest SVM ['Sex_FEMALE', 'Sex_MALE', 'Culmen Length (mm)', 'Culmen Depth (mm)'] : 0.9805429864253394\n\n\nFrom my iterative search through the features and the different models I was able to find that the best score was Logistic Regression with Culmen Length (mm), Culmen Depth (mm), and Sex. This model with these features had a 0.9883107088989442% classification rate. This made sense as I noted in my data exploration that sex was an important distinction to make when comparing different features to classify teh species."
  },
  {
    "objectID": "posts/post1/homework1.html#test-the-models-on-the-test-data",
    "href": "posts/post1/homework1.html#test-the-models-on-the-test-data",
    "title": " Palmer Penguins ",
    "section": "",
    "text": "Next I prepared the test data by shorting my Species column and identifying selected columns of the best fitting models- Culmen Length (mm), Culmen Depth (mm), and Sex for Logistic Regression. On my test data I achieved 100% testing accuracy.\n\ntest_url = \"https://raw.githubusercontent.com/PhilChodrow/ml-notes/main/data/palmer-penguins/test.csv\"\ntest = pd.read_csv(test_url)\n\ntest[\"Species\"] = test[\"Species\"].str.split().str.get(0)\n\nX_test, y_test = prepare_data(test)\n\nselected_cols = ['Culmen Length (mm)', 'Culmen Depth (mm)','Sex_FEMALE', 'Sex_MALE']\n\nX_train_selected = X_train[selected_cols]\nX_test_selected = X_test[selected_cols]\n\nLR = LogisticRegression()\nLR.fit(X_train_selected, y_train)\ntestScore = LR.score(X_test_selected, y_test)\n\nprint(testScore)\n\n1.0\n\n\n/Users/lindseyschweitzer/anaconda3/envs/ml-0451/lib/python3.9/site-packages/sklearn/linear_model/_logistic.py:460: ConvergenceWarning: lbfgs failed to converge (status=1):\nSTOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n\nIncrease the number of iterations (max_iter) or scale the data as shown in:\n    https://scikit-learn.org/stable/modules/preprocessing.html\nPlease also refer to the documentation for alternative solver options:\n    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n  n_iter_i = _check_optimize_result("
  },
  {
    "objectID": "posts/post1/homework1.html#plotting-decision-regions",
    "href": "posts/post1/homework1.html#plotting-decision-regions",
    "title": " Palmer Penguins ",
    "section": "",
    "text": "I visualized how my model worked on the training and test data by plotting the data and displaying the decision regions of my model.\n\nfrom matplotlib import pyplot as plt\nimport numpy as np\n\nfrom matplotlib.patches import Patch\n\ndef plot_regions(model, X, y):\n    \n    x0 = X[X.columns[0]]\n    x1 = X[X.columns[1]]\n    qual_features = X.columns[2:]\n    \n    fig, axarr = plt.subplots(1, len(qual_features), figsize = (7, 3))\n\n    # create a grid\n    grid_x = np.linspace(x0.min(),x0.max(),501)\n    grid_y = np.linspace(x1.min(),x1.max(),501)\n    xx, yy = np.meshgrid(grid_x, grid_y)\n    \n    XX = xx.ravel()\n    YY = yy.ravel()\n\n    for i in range(len(qual_features)):\n      XY = pd.DataFrame({\n        X.columns[0] : XX,\n        X.columns[1] : YY\n      })\n\n      for j in qual_features:\n        XY[j] = 0\n\n      XY[qual_features[i]] = 1\n\n      p = model.predict(XY)\n      p = p.reshape(xx.shape)\n      \n      \n      # use contour plot to visualize the predictions\n      axarr[i].contourf(xx, yy, p, cmap = \"jet\", alpha = 0.2, vmin = 0, vmax = 2)\n      \n      ix = X[qual_features[i]] == 1\n      # plot the data\n      axarr[i].scatter(x0[ix], x1[ix], c = y[ix], cmap = \"jet\", vmin = 0, vmax = 2)\n      \n      axarr[i].set(xlabel = X.columns[0], \n            ylabel  = X.columns[1], \n            title = qual_features[i])\n      \n      patches = []\n      for color, spec in zip([\"red\", \"green\", \"blue\"], [\"Adelie\", \"Chinstrap\", \"Gentoo\"]):\n        patches.append(Patch(color = color, label = spec))\n\n      plt.legend(title = \"Species\", handles = patches, loc = \"best\")\n      \n      plt.tight_layout()\n\nplot_regions(LR, X_train_selected, y_train)\n\n\n\n\n\n\n\n\n\nplot_regions(LR, X_test_selected, y_test)"
  },
  {
    "objectID": "posts/post1/homework1.html#confusion-matrix",
    "href": "posts/post1/homework1.html#confusion-matrix",
    "title": " Palmer Penguins ",
    "section": "",
    "text": "Finally, to visualize the successful identification of my model with my three chosen characteristics I used a confusion matrix on the testing data.\n\nfrom sklearn.metrics import confusion_matrix\n\ny_test_pred = LR.predict(X_test_selected)\nC = confusion_matrix(y_test, y_test_pred)\n\nfor i in range(3):\n    for j in range(3):\n        print(f\"There were {C[i,j]} {le.classes_[i]} penguin(s) who were classified as {le.classes_[j]}.\")\n\nThere were 31 Adelie penguin(s) who were classified as Adelie.\nThere were 0 Adelie penguin(s) who were classified as Chinstrap.\nThere were 0 Adelie penguin(s) who were classified as Gentoo.\nThere were 0 Chinstrap penguin(s) who were classified as Adelie.\nThere were 11 Chinstrap penguin(s) who were classified as Chinstrap.\nThere were 0 Chinstrap penguin(s) who were classified as Gentoo.\nThere were 0 Gentoo penguin(s) who were classified as Adelie.\nThere were 0 Gentoo penguin(s) who were classified as Chinstrap.\nThere were 26 Gentoo penguin(s) who were classified as Gentoo.\n\n\n\nfrom sklearn.metrics import confusion_matrix\n\nconfusion_matrix(y_test, y_test_pred, normalize = \"true\")\n\narray([[1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.]])\n\n\nThis is a perfect confusion matrix as the model has 100% testing accuracy in classifying the penguins. This result is exactly what we want."
  },
  {
    "objectID": "posts/post1/homework1.html#discussion",
    "href": "posts/post1/homework1.html#discussion",
    "title": " Palmer Penguins ",
    "section": "",
    "text": "This blog post taught me many things. Firstly, it allowed me to gain practice exploring and understanding data. I was able to explore the Palmer Penguin data set by creating tables and graphs. Then I was able to use the knowledge gained by the exploration to train my own classifier. I was able to become familiar with various different machine learning models through this assignment: Logistic Regression, Decision Tree Classifier, Random Forest Classifier, and Support Vector Machines. Through this process, I learned about grid search and how to find optimal parameters. I then got practice training a Logistic Regression with Culmen Length (mm), Culmen Depth (mm), and Sex and finally testing it on our test data to get a 100% accuracy rate. Not only did I become more familiar with this particular data set, but I was able to learn skills in how to analyze data and build and test Machine Learning Models."
  },
  {
    "objectID": "posts/post3/homework3.html#data-prep",
    "href": "posts/post3/homework3.html#data-prep",
    "title": " Dissecting racial bias in an algorithm used to manage the health of populations ",
    "section": "1. Data Prep",
    "text": "1. Data Prep\n\npercent_five_cond = (len(df[df[\"gagne_sum_t\"] &lt;= 5])/ len(df)) * 100\npercent_five_cond\n\n95.53952115447689\n\n\n95.5% of patients in the data have five or fewer chronic conditions. Therefore we can justify focusing on these patients as they represent the vast majority of cases.\nLog-transformed the cost by created a column of the data frame that is the logarithm of the cost column. First removed all zero values as log(0) is undefined. Will use this new column as the target variable.\n\nimport numpy as np\n\ndf = df[df[\"cost_t\"] != 0]\ndf[\"log_cost\"] = np.log(df[\"cost_t\"])\n\n/var/folders/g2/ybhd80ns31sc72zl62c5qcjm0000gn/T/ipykernel_64161/702178963.py:4: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  df[\"log_cost\"] = np.log(df[\"cost_t\"])\n\n\nI created a dummy (one-hot encoded) column for the qualitative race variable in which 0 means that the patient is White and 1 means that the patient is Black.\n\ndf[\"is_black\"] = df[\"race\"] == \"black\"\n\n/var/folders/g2/ybhd80ns31sc72zl62c5qcjm0000gn/T/ipykernel_64161/3239834182.py:1: SettingWithCopyWarning: \nA value is trying to be set on a copy of a slice from a DataFrame.\nTry using .loc[row_indexer,col_indexer] = value instead\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n  df[\"is_black\"] = df[\"race\"] == \"black\"\n\n\nI separate the data into predictor variables X and target variable y (the log-cost). For predictor variables, I uses the dummy columns for race and the number of active chronic conditions.\n\nX_train = df[[\"is_black\", \"gagne_sum_t\"]]\ny_train = df[\"log_cost\"]"
  },
  {
    "objectID": "posts/post3/homework3.html#modeling",
    "href": "posts/post3/homework3.html#modeling",
    "title": " Dissecting racial bias in an algorithm used to manage the health of populations ",
    "section": "2. Modeling",
    "text": "2. Modeling\nFunction that will construct data sets with polynomial features of various sizes:\n\ndef add_polynomial_features(X, degree):\n  X_ = X.copy()\n  for j in range(1, degree):\n    X_[f\"poly_{j}\"] = X_[\"gagne_sum_t\"]**j\n  return X_\n\nI trained Linear Regressions on varying numbers of features from 1 to 11, comparing the scores to find that the optimal score is using 10 features: [‘is_black’, ‘gagne_sum_t’, ‘poly_1’, ‘poly_2’, ‘poly_3’, ‘poly_4’,‘poly_5’, ‘poly_6’, ‘poly_7’, ‘poly_8’, ‘poly_9’] to predict log cost.\n\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import cross_val_score\n\nscore = 0\nbest_score = float('-inf')\n\nfor degrees in range(1,11):\n        \n    X_features = add_polynomial_features(X_train, degrees)\n    cols = X_features.columns\n\n    LR = LinearRegression()\n    LR.fit(X_features, y_train)\n    score = cross_val_score(LR, X_features, y_train, cv=5).mean()\n    \n    if (score &gt; best_score):\n        best_score = score\n        best_degrees = degrees\n        best_cols = cols\n\nprint(f\"{best_cols=}\") \nprint(f\"{best_degrees=}\")\n\nbest_cols=Index(['is_black', 'gagne_sum_t', 'poly_1', 'poly_2', 'poly_3', 'poly_4',\n       'poly_5', 'poly_6', 'poly_7', 'poly_8', 'poly_9'],\n      dtype='object')\nbest_degrees=10\n\n\nI then constructed a copy of the data with the correct number of polynomial features and fit a last linear regression model on the optimal features.\n\nX_features = add_polynomial_features(X_train, 10)\nLR = LinearRegression()\nLR.fit(X_features, y_train)\n\nLinearRegression()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.LinearRegressionLinearRegression()\n\n\nI determined which coefficients corresponded to each feature of the data.\n\nfeatures = X_features.columns\ncoefs = LR.coef_\n\nfeature_coefs = dict(zip(features, coefs))\nfeature_coefs\n\n{'is_black': -0.26711487503849624,\n 'gagne_sum_t': 0.5088163229433447,\n 'poly_1': 0.5088164579853922,\n 'poly_2': -1.0305677844477263,\n 'poly_3': 0.5880247944191436,\n 'poly_4': -0.1776219992097652,\n 'poly_5': 0.03115568304493425,\n 'poly_6': -0.0032705785216849033,\n 'poly_7': 0.00020192700428754498,\n 'poly_8': -6.7458039893789564e-06,\n 'poly_9': 9.390071161850347e-08}\n\n\nI computed \\(e^{w_b}\\) to find the estimate of the cost incurred by Black patients as a percentage of white patients.\n\nimport math\n\nmath.exp(feature_coefs[\"is_black\"])\n\n0.7655851197936364\n\n\nMy model shows that black patients incur a cost of 76% of that of white patients. This supports the argument of Obermeyer et al. (2019) as it proves that less money is spent on Black patients who have the same level of need. Therefore as the algorithm uses cost as a proxy for need it thus falsely concludes that Black patients are healthier than equally sick White patients. Reformulating the algorithm so that it no longer uses costs as a proxy for needs eliminates the racial bias in predicting who needs extra care."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Awesome CSCI 0451 Blog",
    "section": "",
    "text": "Palmer Penguins \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Newton’s Method for Logistic Regression \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Dissecting racial bias in an algorithm used to manage the health of populations \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Implementing the Perceptron Algorithm \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "warmups/warmup0411.html",
    "href": "warmups/warmup0411.html",
    "title": "My Awesome CSCI 0451 Blog",
    "section": "",
    "text": "import torch \nfrom matplotlib import pyplot as plt\nplt.style.use('seaborn-v0_8-whitegrid')\nn_points = 100\nx = torch.rand(n_points)\ny = 1*((x + 0.3*(torch.rand(n_points) - 0.5)) &gt; 0.5 )\n\ndef plot_1d_classification_data(x, y, ax):\n    \n    targets = [0, 1]\n    markers = [\"o\" , \",\"]\n    for i in range(2):\n        ix = y == targets[i]\n        ax.scatter(x[ix], torch.zeros_like(x[ix]), s = 40,  c = y[ix], facecolors = \"none\", edgecolors = \"darkgrey\", cmap = \"BrBG\", vmin = -1, vmax = 2, alpha = 0.6, marker = markers[i], )\n    ax.set(xlabel = r\"$x$\")\n    \nfig, ax = plt.subplots(figsize = (10, 1))\nplot_1d_classification_data(x, y, ax)\n\n\nx_space = torch.linspace(0, 1, 1001)\n\n\ndef kernel_classifier(x_space, x, y, gamma):\n    \n    # compute difference between every elem in x_space and x\n    diffs = x_space[:, None] - x\n    \n    prod = y * torch.exp(-gamma * diffs**2)\n    \n    s = torch.sum(prod, dim=1)\n    \n    return s\n\n\ns = kernel_classifier(x_space, x, y, gamma=100)\n\nfig, ax = plt.subplots(2, 1, figsize = (5, 4), height_ratios= (0.8, 0.2))\nax[0].plot(x_space, s, color = \"slategrey\")\nax[0].set(ylabel = \"Kernel score\")\nplot_1d_classification_data(x, y, ax[1])\n\n\ns = kernel_classifier(x_space, x, y, gamma=1)\n\nfig, ax = plt.subplots(2, 1, figsize = (5, 4), height_ratios= (0.8, 0.2))\nax[0].plot(x_space, s, color = \"slategrey\")\nax[0].set(ylabel = \"Kernel score\")\nplot_1d_classification_data(x, y, ax[1])\n\n\ns = kernel_classifier(x_space, x, y, gamma=10000)\n\nfig, ax = plt.subplots(2, 1, figsize = (5, 4), height_ratios= (0.8, 0.2))\nax[0].plot(x_space, s, color = \"slategrey\")\nax[0].set(ylabel = \"Kernel score\")\nplot_1d_classification_data(x, y, ax[1])"
  },
  {
    "objectID": "warmups/warmup0325.html",
    "href": "warmups/warmup0325.html",
    "title": "My Awesome CSCI 0451 Blog",
    "section": "",
    "text": "import matplotlib.pyplot as plt\nimport numpy as np\n\ndef f(z):\n    return 1/(1 + np.exp(-z))\n\nz_val = np.linspace(-1, 1, 100)\n\ny = f(z_val)\n\nplt.plot(z_val, y)\n\nplt.grid(True)\nplt.show()"
  },
  {
    "objectID": "warmups/warmup0317.html",
    "href": "warmups/warmup0317.html",
    "title": "My Awesome CSCI 0451 Blog",
    "section": "",
    "text": "import math\n\ndef mystery_fun(a, epsilon, alpha, maxsteps=100):\n    \n    # start with initial guess \n    x = a\n    \n    # set x'= 0, j'=0\n    x_prime = 1\n    j = 0\n    \n    while(math.fabs(x_prime - x) &gt; epsilon):\n        \n        if j &gt; maxsteps:\n            break\n        \n        x = x_prime\n        \n        x_prime = x - alpha * (x - a/x)\n        \n        j += 1\n    return x\n        \n\n\nx_val = mystery_fun(a = 9, epsilon = 1e-8, alpha = 0.5)\nprint(x_val)\n\n\nx_val = mystery_fun(a = 9, epsilon = 1e-8, alpha = 2000000)\nprint(x_val)"
  }
]